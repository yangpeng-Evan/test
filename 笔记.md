# 回顾:

```
1. 使用注解实现IOC|DI.
	1. 创建项目.
	2. 导入依赖
		beans , core , context , expression language , aop , commons-logging , junit
	3. 声明三层的类以及接口.
	4. 编写配置文件.
		开启注解扫描.
		引入context的schema约束.
		<context:component-scan base-package="com.qf.controller,com.qf.service,com..." />
	5. 添加注解.
    	1. IOC. (添加在类上)
    		@Controller.
    		@Service.
    		@Repository.
    		@Component
    		使用注解实现IOC时,实例在IOC容器中的唯一标识类名的首字母小写.
    	2. DI.	(添加在属性上)
    		@Autowired	(spring提供的.)
    			自动类型注入. -> 去IOC容器中找类型一致的Bean实例. BeanCreationException
    			如果在IOC容器中,找到了多个符合类型要求的实例,通过@Qualifier指定某一个.
    		@Resource	(java规范提供的)
    			Resource默认情况下,先根据属性的名称去IOC容器找实例,如果找不到,再根据类型去找.
    			Resource(name = "") -> 只根据名称去IOC容器找指定的实例.
    			Resource(type = Class<T>) -> 只根据类型去IOC容器找指定的实例.
    			Resource(name = "",type = Class<T>) -> 根据标识和类型去找指定的实例.
	6. 测试.
	
	7. IOC注解的详情.
		@Scope -> 添加在类上. 指定作用域.
		@Lazy -> 添加在类上,添加在属性上. 懒加载/延迟加载.
		@DependsOn -> 添加在类上,在初始化当前类实例前,先去初始化@DependsOn("xxx,yyy,zzz..")
		@PostConstruct -> 添加在方法上,init-method.
		@PreDestroy -> 添加在方法上,destroy-method.
		
2. spring整合junit.
	1. 导入依赖.
		beans , core , context , expression language , aop ,junit4 , spring-test
	2. 两个注解.
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration({"","","不要使用*"...})
	3. 在当前的测试类中,使用DI注解,注入需要测试的bean实例.
	4. @Test方法中进行测试.
	
3. spring的AOP介绍.
	1. 什么是AOP.	面向切面编程. Aspect Ori... Program... 
		将共性的代码横向抽取出来,在不改变被代理类的源代码的前提下,动态将共性的代码织入.
	2. AOP的由来.
		aop联盟提出aop思想.
		aspectJ提出规范.
		spring的AOP实现了aspectJ提出规范.
	3. AOP的原理.
		动态代理.
			jdk动态代理(默认).
				被代理类必须有实现的接口.
			cglib动态代理.
				如果被代理类没有实现的接口,采用cglib.
				被代理类不能被final修饰.
				cglib比jdk动态代理快了一啾啾.
	
4. AOP的相关术语.
	1. 连接点.(joinpoint)		->	可以被增强的方法.
	2. 切入点.(pointcut)		->	真正被增强的方法. (切入点表达式)
	3. 增强/通知.(advice)  ->	抽取出来的共性代码,共性的功能.
	4. 切面.(aspect)		->	将增强织入到切入点中.

5. AOP的入门.
	1. 创建项目.
	2. 导入依赖.
		spring -> beans,core,context,expression,aop,aspects,test (版本完全一致)
		commons-logging,aspectJ,junit
	3. 准备连接点和增强类.
	4. 编写配置文件.
		1. 将连接点和增强IOC容器构建出来.
		2. 配置切入点
			<aop:config>
				切入点
				<aop:pointcut id="唯一标识" 
							expression="访问修饰符 返回值类型 包名.类名.方法名(方法参数)" />
										省略 * com.qf.service.impl.*.*(..)
				切面
				<aop:aspect ref="增强类的id">
					前置增强.
					<aop:before method="增强方法" pointcut-ref="" />
					后置增强.
					<aop:after-returning method="增强方法" pointcut-ref="" returning="" />
					环绕增强.
					异常增强.
					<aop:after-throwing method="增强方法" pointcut-ref="" throwing="" />
					最终增强.
					<aop:after method="增强方法" pointcut-ref="" />
				</aop:aspect>
			</aop:config>
		3. 增强类中的增强方法里,可以添加一个JoinPoint的形参,可以通过JoinPoint的形参获取被增强的方法的信息.
```

# 一. 注解实现AOP.

### 1. 创建项目.

### 2. 导入依赖.

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>4.3.8.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>4.3.8.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>4.3.8.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
</dependencies>
```

### 3. 准备连接点和增强.

```java
joinpoint:
public class UserServiceImpl implements UserService {

    @Override
    public void save() {
        System.out.println("save..........");
    }
}
```

```java
advice:
public class MyAdvice {

    public void before(){
        System.out.println("前置增强!!!");
    }
    public void afterReturning(){
        System.out.println("后置增强!!!");
    }
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("环绕前置增强!!!");
        Object result = pjp.proceed();
        System.out.println("环绕后置增强!!!");
    }
    public void afterThrowing(){
        System.out.println("异常增强!!!");
    }
    public void after(){
        System.out.println("最终增强!!!");
    }
}
```

### 4. 编写配置文件.

```xml
<!--    1. 开启IOC和DI的注解扫描-->
    <context:component-scan base-package="com.qf.advice,com.qf.service" />

<!--    2. 开启AOP注解扫描
        proxy-target-class="true" 使用cglib动态代理
        proxy-target-class="false"(默认值) -->
    <aop:aspectj-autoproxy  />
```

### 5. 添加注解.

```
1. 由IOC创建连接点对象实例和增强对象实例.
	给UserServiceImpl添加@Service注解.
	给MyAdvice添加@Component注解.

2. 添加切入点和切面的配置.
	2.1 声明切入点.
            在增强类中,添加一个普通方法.
            在当前方法上添加注解. 
            @Pointcut("切入点表达式.")
    2.2 配置切面   
    		1. 在增强类上添加注解@Aspect  代表在当前类中配置切面.
    		2. 在增强方法上添加增强的注解.
    			@Before(value = "切入点")
    			@AfterReturning(value = "切入点",returning = "")
    			@Around(value = "")
    			@AfterThrowing(value = "" , throwing = "")
    			@After(value = "")
3. 小坑,....
	在给增强类中的增强方法添加参数时,一定要注意将JoinPoint放在参数的前面,避免 :: a 错误的发生.
```

### 6. 测试.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:applicationContext.xml"})
public class UserServiceTest {

    @Autowired
    private UserService userService;

    @Test
    public void save() {
        userService.save();
    }
}
```





























后续:

# spring的JdbcTemplate

# spring的声明式事务.

# spring整合mybatis.

# 找个demo -> 完成service层和dao层.

# springmvc.

# git/svn.(必须要会)

# shiro.安全框架.

# quartz. 定时任务.

# springboot.跨域.

# 项目.

# Linux.

# 三大中间.

# 三大分布式处理方案.

# 两个微服务解决方法.

# 多写项目.